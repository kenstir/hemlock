#-----------------------------------------
# SHARED fastlane config
#
# usage: import "../../fastlane/Fastfile"
#-----------------------------------------

require_relative './lib/get_active_users'

#-----------------------------------------
# funcs

# Returns absolute path to repo root
def get_repo_root
  File.expand_path("..", __dir__)
end

def find_aab_for(project)
  repo_root = get_repo_root()
  aab = Dir.glob("#{repo_root}/#{project}/build/outputs/bundle/release/*_app-release.aab").first
  UI.user_error!("No such file: #{repo_root}/#{project}/build/outputs/bundle/release/*_app-release.aab") unless aab
  aab
end

# Returns full path to the current project's AAB
def find_aab
  find_aab_for(get_project())
end

# Returns name of the current project, e.g. "hemlock_app" or errors
# (curiously one level up from the project's Fastfile)
def get_project
  project = File.basename(File.expand_path("..", Dir.pwd))
  UI.message("project = #{project}")
  if not project.end_with?("_app")
    UI.user_error!("must be run from the x_app project subdirectory")
  end
  project
end

# Returns [tag, message] for use in annotated tag
def get_tag_info
  app = get_project().delete_suffix("_app")
  UI.message("app: #{app}")

  versionCode, versionName = get_version_info("../../version.gradle")
  UI.message("versionCode: #{versionCode}")
  UI.message("versionName: #{versionName}")

  tag = "#{app}_v#{versionCode}"
  msg = "#{tag} (#{versionName})"

  return tag, msg
end

# Returns [versionCode, versionString] scraped from version.gradle
def get_version_info(path = "../version.gradle")
  content = File.read(path)

  m = content.match(/(globalVersionCode\s*=\s*)(\d+)/)
  UI.user_error!("\"globlVersionCode\" not found in #{path}") unless m

  versionCode = m[2]

  m = content.match(/(globalVersionName\s*=\s*")(\d+)\.(\d+)\.(\d+)\.(\d+)(")/)
  UI.user_error!("\"globlVersionName\" not found in #{path}") unless m

  major  = m[2]
  minor  = m[3]
  patch  = m[4]
  build  = m[5]
  versionName = "#{major}.#{minor}.#{patch}.#{build}"

  return versionCode, versionName
end

def increment_version_code(path = "../version.gradle")
  content = File.read(path)

  new_content = content.gsub(/(globalVersionCode\s*=\s*)(\d+)/) do
    prefix = Regexp.last_match(1)
    number = Regexp.last_match(2).to_i + 1
    "#{prefix}#{number}"
  end

  File.write(path, new_content)
end

def increment_version_string(part = :patch, path = "../version.gradle")
  content = File.read(path)

  new_content = content.gsub(/(globalVersionName\s*=\s*")(\d+)\.(\d+)\.(\d+)\.(\d+)(")/) do
    prefix = Regexp.last_match(1)
    major  = Regexp.last_match(2).to_i
    minor  = Regexp.last_match(3).to_i
    patch  = Regexp.last_match(4).to_i
    build  = Regexp.last_match(5).to_i
    suffix = Regexp.last_match(6)

    case part.to_sym
    when :major
      major += 1
      minor = 0
      patch = 0
    when :minor
      minor += 1
      patch = 0
    when :patch
      patch += 1
    when :build
      build += 1
    else
      raise ArgumentError, "part must be :major, :minor, or :patch"
    end

    "#{prefix}#{major}.#{minor}.#{patch}.#{build}#{suffix}"
  end

  File.write(path, new_content)
end

# Prints a message with a prefix so it can be easily scraped
def msg(msg)
  UI.message("kcx: #{msg}")
end

#-----------------------------------------
# debug

desc "Dump vars for testing"
lane :dumpvars do
  repo_root = get_repo_root()
  UI.message("repo_root:   #{repo_root}")

  project = get_project()
  UI.message("project:     #{project}")

  aab = find_aab()
  UI.message("aab:         #{aab}")

  ENV.each do |key, value|
    UI.message("   #{key}=#{value}")
  end
end

desc "noop for timing"
lane :noop do
  msg("noop")
end

#-----------------------------------------
# building and releasing

desc "Run all the tests"
lane :test do
  Dir.chdir("..") do
    sh("bash ./tools/jdkrun.sh ./gradlew test")
    sh("bash ./tools/jdkrun.sh ./gradlew connectedAndroidTest")
  end
end

desc "Create a release AAB"
lane :make_release do
  project = get_project()
  # 2025-12-01: ../gradlew bundleRelease fails for acorn,cwmars
  #             but ./gradlew :cwmars:bundleRelease works
  Dir.chdir("../..") do
    sh("bash ./tools/jdkrun.sh ./gradlew :#{project}:bundleRelease")
  end
end

desc "Upload release AAB to the open testing channel"
lane :upload_beta do
  upload_to_play_store(
    aab: find_aab(),
    track: "beta",
    release_status: "completed",
    skip_upload_metadata: true,
    skip_upload_changelogs: false,
    skip_upload_images: true,
    skip_upload_screenshots: true
  )
end

desc "Make release AAB + upload to the open testing channel"
lane :beta do
  #ensure_git_status_clean
  tag, msg = get_tag_info()
  if git_tag_exists(tag: tag, remote: true)
    UI.user_error!("tag already exists: #{tag}")
  end
  UI.message("tag: #{tag}")
  UI.message("msg: #{msg}")

  make_release

  upload_beta

  add_git_tag(
    tag: tag,
    message: msg,
    grouping: nil
  )
  push_git_tags(tag: tag)
end

desc "Promote beta app to production"
lane :promote_beta do
  app = get_project().delete_suffix("_app")
  versionCode, versionName = get_version_info("../../version.gradle")
  beta_versions = google_play_track_version_codes(track: "beta")
  prod_versions = google_play_track_version_codes(track: "production")

  UI.message("app:           #{app}")
  UI.message("versionCode:   #{versionCode}")
  UI.message("beta_versions: #{beta_versions}")
  UI.message("prod_versions: #{prod_versions}")

  UI.user_error!("More than 1 beta version") unless beta_versions.length == 1
  UI.user_error!("More than 1 prod version") unless prod_versions.length == 1
  beta_version = beta_versions.first
  prod_version = prod_versions.first

  if beta_version == prod_version
    UI.message("same version")
    next
  end

  upload_to_play_store(
    track: "beta",
    track_promote_to: "production",
    rollout: "1.0",
    version_code: beta_version
  )
end

lane :show_version_codes do
  app = get_project().delete_suffix("_app")
  versionCode, versionName = get_version_info("../../version.gradle")
  beta_versions = google_play_track_version_codes(track: "beta")
  prod_versions = google_play_track_version_codes(track: "production")

  msg("app:           #{app}")
  msg("versionCode:   #{versionCode}")
  msg("beta_versions: #{beta_versions}")
  msg("prod_versions: #{prod_versions}")
end

lane :show_all_version_codes do
  # fastlane is weird in that it operates with cwd of fastlane/
  Dir.glob("../*_app/fastlane").each do |project_fastlane|
    Dir.chdir(project_fastlane) do
      UI.message("Chdir #{Dir.pwd}")
      show_version_codes
    end
  end
end

#-----------------------------------------
# maintaining version numbers

lane :bump_version_major do
  increment_version_string(:major)
end

lane :bump_version_minor do
  increment_version_string(:minor)
end

lane :bump_version_patch do
  increment_version_string(:patch)
end

lane :bump_version_build do
  increment_version_string(:build)
end

lane :bump_version_code do
  increment_version_code
end

lane :print_build_info do
  versionCode, versionName = get_version_info("../version.gradle")
  msg("versionCode: #{versionCode}")
  msg("versionName: #{versionName}")
end
lane :v do
  print_build_info
end

#-----------------------------------------
# Firebase Analytics

lane :print_active_users do
  app = get_project().delete_suffix("_app")
  active_users = get_active_28d_users(app)

  ios = active_users['iOS']
  android = active_users['Android']
  total = ios + android
  msg("active_28d_users_ios:     #{ios}")
  msg("active_28d_users_android: #{android}")
  msg("active_28d_users_total:   #{total}")
end
